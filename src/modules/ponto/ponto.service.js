const prisma = require('../../config/prisma');
const { Errors } = require('../../shared/errors/AppError');

class PontoService {

  async listarEscalas(tenantId) {
    return prisma.escalaTrabalho.findMany({
      where: { OR: [{ tenantId }, { tenantId: null }] }, // null = escalas globais do sistema
      orderBy: { nome: 'asc' },
    });
  }

  async criarEscala(tenantId, dados) {
    return prisma.escalaTrabalho.create({ data: { ...dados, tenantId } });
  }

  async atualizarEscala(tenantId, id, dados) {
    const e = await prisma.escalaTrabalho.findFirst({ where: { id, tenantId } });
    if (!e) throw Errors.NOT_FOUND('Escala');
    return prisma.escalaTrabalho.update({ where: { id }, data: dados });
  }

  async vincularServidorEscala(tenantId, escalaId, { servidorId, dataInicio, dataFim }) {
    const srv = await prisma.servidor.findFirst({ where: { id: servidorId, tenantId } });
    if (!srv) throw Errors.NOT_FOUND('Servidor');

    // Desativa vínculo anterior ativo
    await prisma.servidorEscala.updateMany({
      where: { servidorId, ativo: true },
      data: { ativo: false, dataFim: new Date() },
    });

    return prisma.servidorEscala.create({
      data: { servidorId, escalaId, dataInicio: new Date(dataInicio), dataFim: dataFim ? new Date(dataFim) : null },
    });
  }

  async espelho(tenantId, servidorId, mes) {
    // mes = YYYY-MM
    const srv = await prisma.servidor.findFirst({
      where: { id: servidorId, tenantId },
      select: { id: true, matricula: true, nome: true, cargo: { select: { nome: true } }, lotacao: { select: { nome: true } } },
    });
    if (!srv) throw Errors.NOT_FOUND('Servidor');

    const [ano, mesNum] = mes.split('-').map(Number);
    const dataInicio = new Date(ano, mesNum - 1, 1);
    const dataFim    = new Date(ano, mesNum, 0); // último dia do mês

    const registros = await prisma.registroPonto.findMany({
      where: { servidorId, data: { gte: dataInicio, lte: dataFim } },
      orderBy: { data: 'asc' },
    });

    // Totalizadores do mês
    const totais = registros.reduce((acc, r) => {
      acc.horasTrabalhadas += Number(r.horasTrabalhadas || 0);
      acc.horasExtras      += Number(r.horasExtras || 0);
      acc.horasFalta       += Number(r.horasFalta || 0);
      acc.faltas           += r.ocorrencia === 'FALTA_INJUSTIFICADA' ? 1 : 0;
      acc.faltasJustif     += r.ocorrencia === 'FALTA_JUSTIFICADA' ? 1 : 0;
      return acc;
    }, { horasTrabalhadas: 0, horasExtras: 0, horasFalta: 0, faltas: 0, faltasJustif: 0 });

    return { servidor: srv, mes, registros, totais };
  }

  async lancar(tenantId, dados) {
    // Valida servidor
    const srv = await prisma.servidor.findFirst({ where: { id: dados.servidorId, tenantId } });
    if (!srv) throw Errors.NOT_FOUND('Servidor');

    const data = new Date(dados.data);
    const entrada  = dados.entrada  ? new Date(dados.entrada)  : null;
    const saida    = dados.saida    ? new Date(dados.saida)    : null;

    // Calcula horas trabalhadas
    let horasTrabalhadas = 0;
    let horasExtras = 0;
    let horasFalta = 0;

    if (entrada && saida) {
      const intervaloMin = dados.intervaloMin || 60;
      const totalMin = (saida - entrada) / 60000 - intervaloMin;
      horasTrabalhadas = parseFloat((totalMin / 60).toFixed(2));

      // Busca escala do servidor para calcular horas extras/falta
      const escalaVinc = await prisma.servidorEscala.findFirst({
        where: { servidorId: dados.servidorId, ativo: true },
        include: { escala: true },
      });
      if (escalaVinc) {
        const esperadas = Number(escalaVinc.escala.horasDiarias);
        const diff = horasTrabalhadas - esperadas;
        if (diff > 0) horasExtras = parseFloat(diff.toFixed(2));
        else if (diff < 0) horasFalta = parseFloat(Math.abs(diff).toFixed(2));
      }
    }

    return prisma.registroPonto.upsert({
      where: { servidorId_data: { servidorId: dados.servidorId, data } },
      create: {
        ...dados,
        data,
        entrada, saida,
        saidaAlmoco: dados.saidaAlmoco ? new Date(dados.saidaAlmoco) : null,
        retornoAlmoco: dados.retornoAlmoco ? new Date(dados.retornoAlmoco) : null,
        horasTrabalhadas, horasExtras, horasFalta,
      },
      update: { entrada, saida, horasTrabalhadas, horasExtras, horasFalta, ocorrencia: dados.ocorrencia || null },
    });
  }

  async importar(tenantId, { servidorId, registros }) {
    // registros = array de { data, entrada, saida, ... }
    const srv = await prisma.servidor.findFirst({ where: { id: servidorId, tenantId } });
    if (!srv) throw Errors.NOT_FOUND('Servidor');

    const resultados = [];
    for (const reg of registros) {
      try {
        const r = await this.lancar(tenantId, { ...reg, servidorId, origem: 'REP_P' });
        resultados.push({ data: reg.data, status: 'ok', id: r.id });
      } catch (e) {
        resultados.push({ data: reg.data, status: 'erro', mensagem: e.message });
      }
    }
    return { total: registros.length, importados: resultados.filter(r => r.status === 'ok').length, resultados };
  }

  async abonar(tenantId, id, { justificativa }, userId) {
    const reg = await prisma.registroPonto.findFirst({
      where: { id },
      include: { servidor: true },
    });
    if (!reg || reg.servidor.tenantId !== tenantId) throw Errors.NOT_FOUND('Registro de ponto');

    return prisma.registroPonto.update({
      where: { id },
      data: { abonado: true, justificativa, abonadoEm: new Date() },
    });
  }

  async registrarOcorrencia(tenantId, id, { ocorrencia, justificativa }) {
    const reg = await prisma.registroPonto.findFirst({
      where: { id },
      include: { servidor: true },
    });
    if (!reg || reg.servidor.tenantId !== tenantId) throw Errors.NOT_FOUND('Registro de ponto');
    return prisma.registroPonto.update({ where: { id }, data: { ocorrencia, justificativa } });
  }

  async bancohoras(tenantId, servidorId) {
    const srv = await prisma.servidor.findFirst({ where: { id: servidorId, tenantId } });
    if (!srv) throw Errors.NOT_FOUND('Servidor');

    const movimentos = await prisma.bancoHoras.findMany({
      where: { servidorId },
      orderBy: { data: 'desc' },
      take: 50,
    });

    const saldoAtual = movimentos.length > 0 ? Number(movimentos[0].saldo) : 0;
    return { servidorId, saldoAtual, movimentos };
  }

  async compensar(tenantId, servidorId, { horas, data, descricao }) {
    const srv = await prisma.servidor.findFirst({ where: { id: servidorId, tenantId } });
    if (!srv) throw Errors.NOT_FOUND('Servidor');

    const { saldoAtual } = await this.bancohoras(tenantId, servidorId);
    if (horas > saldoAtual) throw Errors.VALIDATION(`Saldo de banco de horas insuficiente. Disponível: ${saldoAtual}h`);

    const novoSaldo = parseFloat((saldoAtual - horas).toFixed(2));
    return prisma.bancoHoras.create({
      data: { servidorId, data: new Date(data), tipo: 'DEBITO', horas, saldo: novoSaldo, descricao: descricao || 'Compensação de horas' },
    });
  }

  async resumoMensal(tenantId, mes, query = {}, skip = 0, take = 20) {
    const [ano, mesNum] = mes.split('-').map(Number);
    const dataInicio = new Date(ano, mesNum - 1, 1);
    const dataFim    = new Date(ano, mesNum, 0);

    const where = { servidor: { tenantId } };
    if (query.lotacaoId) where.servidor = { ...where.servidor, lotacaoId: query.lotacaoId };

    const registros = await prisma.registroPonto.groupBy({
      by: ['servidorId'],
      where: { ...where, data: { gte: dataInicio, lte: dataFim } },
      _sum: { horasTrabalhadas: true, horasExtras: true, horasFalta: true },
      _count: { id: true },
      skip, take,
    });

    return { dados: registros, total: registros.length };
  }

  async pendencias(tenantId, query = {}) {
    // Registros sem marcação de saída (ponto aberto)
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0);

    return prisma.registroPonto.findMany({
      where: {
        servidor: { tenantId },
        data: { gte: new Date(hoje.getFullYear(), hoje.getMonth(), 1), lte: hoje },
        entrada: { not: null },
        saida: null,
        ocorrencia: null,
      },
      include: {
        servidor: { select: { matricula: true, nome: true, lotacao: { select: { nome: true } } } },
      },
      orderBy: { data: 'desc' },
    });
  }
}

module.exports = PontoService;
